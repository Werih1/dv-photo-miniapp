<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Green Card Photo Validator</title>
    <style>
        :root {
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-teal-800: rgba(41, 150, 161, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-slate-500-rgb: 98, 108, 113;
  --color-red-500-rgb: 192, 21, 47;
  --color-red-400-rgb: 255, 84, 89;
  --color-orange-500-rgb: 168, 75, 47;
  --color-orange-400-rgb: 230, 129, 97;
  --color-bg-1: rgba(59, 130, 246, 0.08);
  --color-bg-2: rgba(245, 158, 11, 0.08);
  --color-bg-3: rgba(34, 197, 94, 0.08);
  --color-bg-4: rgba(239, 68, 68, 0.08);
  --color-bg-5: rgba(147, 51, 234, 0.08);
  --color-bg-6: rgba(249, 115, 22, 0.08);
  --color-bg-7: rgba(236, 72, 153, 0.08);
  --color-bg-8: rgba(6, 182, 212, 0.08);
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
  --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;
  --color-success-rgb: 33, 128, 141;
  --color-error-rgb: 192, 21, 47;
  --color-warning-rgb: 168, 75, 47;
  --color-info-rgb: 98, 108, 113;
  --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  --font-size-xs: 11px;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-md: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 20px;
  --font-size-3xl: 24px;
  --font-size-4xl: 30px;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 550;
  --font-weight-bold: 600;
  --line-height-tight: 1.2;
  --line-height-normal: 1.5;
  --letter-spacing-tight: -0.01em;
  --space-0: 0;
  --space-1: 1px;
  --space-2: 2px;
  --space-4: 4px;
  --space-6: 6px;
  --space-8: 8px;
  --space-10: 10px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;
  --space-24: 24px;
  --space-32: 32px;
  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-full: 9999px;
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04), 0 4px 6px -2px rgba(0, 0, 0, 0.02);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 -1px 0 rgba(0, 0, 0, 0.03);
  --duration-fast: 150ms;
  --duration-normal: 250ms;
  --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
  --container-sm: 640px;
  --container-md: 768px;
  --container-lg: 1024px;
  --container-xl: 1280px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-gray-400-rgb: 119, 124, 124;
    --color-teal-300-rgb: 50, 184, 198;
    --color-gray-300-rgb: 167, 169, 169;
    --color-gray-200-rgb: 245, 245, 245;
    --color-bg-1: rgba(29, 78, 216, 0.15);
    --color-bg-2: rgba(180, 83, 9, 0.15);
    --color-bg-3: rgba(21, 128, 61, 0.15);
    --color-bg-4: rgba(185, 28, 28, 0.15);
    --color-bg-5: rgba(107, 33, 168, 0.15);
    --color-bg-6: rgba(194, 65, 12, 0.15);
    --color-bg-7: rgba(190, 24, 93, 0.15);
    --color-bg-8: rgba(8, 145, 178, 0.15);
    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-primary-active: var(--color-teal-800);
    --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
    --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
    --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
    --color-border: rgba(var(--color-gray-400-rgb), 0.3);
    --color-error: var(--color-red-400);
    --color-success: var(--color-teal-300);
    --color-warning: var(--color-orange-400);
    --color-info: var(--color-gray-300);
    --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
    --color-btn-primary-text: var(--color-slate-900);
    --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
    --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
    --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1), inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    --color-success-rgb: var(--color-teal-300-rgb);
    --color-error-rgb: var(--color-red-400-rgb);
    --color-warning-rgb: var(--color-orange-400-rgb);
    --color-info-rgb: var(--color-gray-300-rgb);
  }
}

@font-face {
  font-family: 'FKGroteskNeue';
  src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2') format('woff2');
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-family-base);
  background-color: var(--color-background);
  color: var(--color-text);
  line-height: var(--line-height-normal);
  -webkit-font-smoothing: antialiased;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--space-16);
}

.header {
  text-align: center;
  padding: var(--space-24) 0;
  border-bottom: 1px solid var(--color-border);
  margin-bottom: var(--space-24);
}

.header h1 {
  font-size: var(--font-size-3xl);
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--space-8);
}

.header p {
  color: var(--color-text-secondary);
  font-size: var(--font-size-base);
}

.lang-selector {
  position: absolute;
  top: var(--space-16);
  right: var(--space-16);
  display: flex;
  gap: var(--space-8);
}

.lang-btn {
  padding: var(--space-6) var(--space-12);
  border: 1px solid var(--color-border);
  background: var(--color-surface);
  color: var(--color-text);
  border-radius: var(--radius-base);
  cursor: pointer;
  font-size: var(--font-size-sm);
  transition: all var(--duration-fast) var(--ease-standard);
}

.lang-btn.active {
  background: var(--color-primary);
  color: var(--color-btn-primary-text);
  border-color: var(--color-primary);
}

.upload-section {
  background: var(--color-surface);
  border: 2px dashed var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--space-32);
  text-align: center;
  margin-bottom: var(--space-24);
  cursor: pointer;
  transition: all var(--duration-normal) var(--ease-standard);
}

.upload-section:hover {
  border-color: var(--color-primary);
  background: var(--color-bg-1);
}

.upload-section.dragover {
  border-color: var(--color-primary);
  background: var(--color-bg-1);
}

.upload-icon {
  font-size: 48px;
  margin-bottom: var(--space-16);
}

.upload-section h3 {
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-8);
}

.upload-section p {
  color: var(--color-text-secondary);
  margin-bottom: var(--space-16);
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-10) var(--space-24);
  border-radius: var(--radius-base);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  cursor: pointer;
  transition: all var(--duration-normal) var(--ease-standard);
  border: none;
  text-decoration: none;
}

.btn-primary {
  background: var(--color-primary);
  color: var(--color-btn-primary-text);
}

.btn-primary:hover:not(:disabled) {
  background: var(--color-primary-hover);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-secondary {
  background: var(--color-secondary);
  color: var(--color-text);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--color-secondary-hover);
}

#fileInput {
  display: none;
}

.processing-section {
  display: none;
  margin-bottom: var(--space-24);
}

.processing-section.active {
  display: block;
}

.loading {
  text-align: center;
  padding: var(--space-32);
}

.spinner {
  border: 3px solid var(--color-secondary);
  border-top: 3px solid var(--color-primary);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto var(--space-16);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.content-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-24);
  margin-bottom: var(--space-24);
}

@media (max-width: 768px) {
  .content-grid {
    grid-template-columns: 1fr;
  }
}

.card {
  background: var(--color-surface);
  border: 1px solid var(--color-card-border);
  border-radius: var(--radius-lg);
  padding: var(--space-20);
  box-shadow: var(--shadow-sm);
}

.card h3 {
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-16);
  padding-bottom: var(--space-12);
  border-bottom: 1px solid var(--color-card-border-inner);
}

.canvas-container {
  position: relative;
  width: 100%;
  margin-bottom: var(--space-16);
}

#detectionCanvas {
  max-width: 100%;
  height: auto;
  border-radius: var(--radius-base);
  display: block;
}

.validation-list {
  list-style: none;
}

.validation-item {
  display: flex;
  align-items: center;
  padding: var(--space-12);
  margin-bottom: var(--space-8);
  border-radius: var(--radius-base);
  background: var(--color-bg-2);
  border: 1px solid var(--color-border);
}

.validation-item.pass {
  background: rgba(var(--color-success-rgb), 0.1);
  border-color: var(--color-success);
}

.validation-item.fail {
  background: rgba(var(--color-error-rgb), 0.1);
  border-color: var(--color-error);
}

.validation-item.warning {
  background: rgba(var(--color-warning-rgb), 0.1);
  border-color: var(--color-warning);
}

.validation-icon {
  font-size: var(--font-size-xl);
  margin-right: var(--space-12);
  min-width: 24px;
}

.validation-text {
  flex: 1;
}

.validation-label {
  font-weight: var(--font-weight-medium);
  display: block;
  margin-bottom: var(--space-4);
}

.validation-detail {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.metadata-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-12);
}

.metadata-item {
  padding: var(--space-12);
  background: var(--color-bg-1);
  border-radius: var(--radius-base);
}

.metadata-label {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  display: block;
  margin-bottom: var(--space-4);
}

.metadata-value {
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-base);
}

.crop-preview {
  display: none;
  margin-top: var(--space-24);
}

.crop-preview.active {
  display: block;
}

.crop-preview h3 {
  margin-bottom: var(--space-16);
}

#croppedCanvas {
  max-width: 100%;
  height: auto;
  border-radius: var(--radius-base);
  border: 2px solid var(--color-success);
  display: block;
  margin: 0 auto var(--space-16);
}

.action-buttons {
  display: flex;
  gap: var(--space-12);
  justify-content: center;
  flex-wrap: wrap;
}

.flowchart {
  margin-top: var(--space-32);
  text-align: center;
}

.flowchart img {
  max-width: 100%;
  height: auto;
  border-radius: var(--radius-lg);
  border: 1px solid var(--color-border);
}

.error-message {
  background: rgba(var(--color-error-rgb), 0.1);
  border: 1px solid var(--color-error);
  color: var(--color-error);
  padding: var(--space-16);
  border-radius: var(--radius-base);
  margin-bottom: var(--space-16);
}

.success-message {
  background: rgba(var(--color-success-rgb), 0.1);
  border: 1px solid var(--color-success);
  color: var(--color-success);
  padding: var(--space-16);
  border-radius: var(--radius-base);
  margin-bottom: var(--space-16);
  text-align: center;
}

.hidden {
  display: none !important;
}
    </style>
</head>
<body>
    <div class="container">
        <div class="lang-selector">
            <button class="lang-btn active" data-lang="ru">RU</button>
            <button class="lang-btn" data-lang="en">EN</button>
        </div>

        <header class="header">
            <h1 id="appTitle">Green Card Photo Validator</h1>
            <p id="appDescription">–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –¥–ª—è Green Card –ª–æ—Ç–µ—Ä–µ–∏ –°–®–ê</p>
        </header>

        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üì∏</div>
            <h3 id="uploadTitle">–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é</h3>
            <p id="uploadDesc">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞</p>
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                <span id="uploadBtn">–í—ã–±—Ä–∞—Ç—å —Ñ–æ—Ç–æ</span>
            </button>
            <input type="file" id="fileInput" accept="image/jpeg,image/jpg" />
        </div>

        <div class="processing-section" id="processingSection">
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p id="loadingText">–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–µ–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ª–∏—Ü...</p>
            </div>

            <div class="content-grid hidden" id="resultsGrid">
                <div class="card">
                    <h3 id="detectionTitle">–î–µ—Ç–µ–∫—Ü–∏—è –ª–∏—Ü–∞</h3>
                    <div class="canvas-container">
                        <canvas id="detectionCanvas"></canvas>
                    </div>
                    <div class="metadata-grid" id="metadataGrid"></div>
                </div>

                <div class="card">
                    <h3 id="validationTitle">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏</h3>
                    <ul class="validation-list" id="validationList"></ul>
                </div>
            </div>

            <div class="crop-preview" id="cropPreview">
                <div class="card">
                    <div class="success-message" id="successMessage">
                        ‚úì –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã! –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.
                    </div>
                    <h3 id="cropTitle">–û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ —Ñ–æ—Ç–æ 600√ó600</h3>
                    <canvas id="croppedCanvas"></canvas>
                    <div class="action-buttons">
                        <button class="btn btn-primary" id="downloadBtn">
                            <span id="downloadText">‚¨á –°–∫–∞—á–∞—Ç—å —Ñ–æ—Ç–æ</span>
                        </button>
                        <button class="btn btn-secondary" id="resetBtn">
                            <span id="resetText">‚Üª –ó–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–µ —Ñ–æ—Ç–æ</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flowchart">
            <img src="https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/97b500f3aa50c8adc6170e8ef778ff0c/27ea6e70-ce6d-4b43-aa3a-eda3a17eb22d/d5a860a9.png" alt="Validation Process Flowchart" />
        </div>
    </div>

    <!-- MediaPipe Tasks Vision (BlazePose/BlazeFace/Body) WASM CDN & TFJS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exifr/dist/lite.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision"></script>
    
    <script>
        // Translation dictionary
        const translations = {
            ru: {
                appTitle: 'Green Card Photo Validator',
                appDescription: '–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –¥–ª—è Green Card –ª–æ—Ç–µ—Ä–µ–∏ –°–®–ê',
                uploadTitle: '–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é',
                uploadDesc: '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞',
                uploadBtn: '–í—ã–±—Ä–∞—Ç—å —Ñ–æ—Ç–æ',
                loadingModels: '–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–µ–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ª–∏—Ü...',
                processingImage: '–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...',
                detectingFace: '–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ª–∏—Ü–∞...',
                analyzingPhoto: '–ê–Ω–∞–ª–∏–∑ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏...',
                detectionTitle: '–î–µ—Ç–µ–∫—Ü–∏—è –ª–∏—Ü–∞',
                validationTitle: '–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏',
                cropTitle: '–û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ —Ñ–æ—Ç–æ 600√ó600',
                downloadText: '‚¨á –°–∫–∞—á–∞—Ç—å —Ñ–æ—Ç–æ',
                resetText: '‚Üª –ó–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–µ —Ñ–æ—Ç–æ',
                successMessage: '‚úì –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã! –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.',
                // Validation labels
                faceDetected: '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ª–∏—Ü–∞',
                faceDetectedPass: '–õ–∏—Ü–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ',
                faceDetectedFail: '–õ–∏—Ü–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∏–ª–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–∏—Ü',
                fileFormat: '–§–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞',
                fileFormatPass: 'JPEG —Ñ–æ—Ä–º–∞—Ç',
                fileFormatFail: '–¢—Ä–µ–±—É–µ—Ç—Å—è JPEG —Ñ–æ—Ä–º–∞—Ç',
                fileSize: '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞',
                fileSizePass: '–†–∞–∑–º–µ—Ä –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –Ω–æ—Ä–º—ã',
                fileSizeFail: '–†–∞–∑–º–µ—Ä –ø—Ä–µ–≤—ã—à–∞–µ—Ç 240 –ö–ë',
                headHeight: '–í—ã—Å–æ—Ç–∞ –≥–æ–ª–æ–≤—ã',
                headHeightPass: '–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º (50-69%)',
                headHeightFail: '–ù–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 50-69%)',
                eyePosition: '–ü–æ–∑–∏—Ü–∏—è –≥–ª–∞–∑',
                eyePositionPass: '–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º (56-69%)',
                eyePositionFail: '–ù–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 56-69%)',
                headTilt: '–ù–∞–∫–ª–æ–Ω –≥–æ–ª–æ–≤—ã',
                headTiltPass: '–ì–æ–ª–æ–≤–∞ –ø—Ä—è–º–∞—è',
                headTiltFail: '–ì–æ–ª–æ–≤–∞ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∞ –±–æ–ª–µ–µ —á–µ–º –Ω–∞ 10¬∞',
                eyesOpen: '–û—Ç–∫—Ä—ã—Ç—ã–µ –≥–ª–∞–∑–∞',
                eyesOpenPass: '–ì–ª–∞–∑–∞ –æ—Ç–∫—Ä—ã—Ç—ã',
                eyesOpenFail: '–ì–ª–∞–∑–∞ –∑–∞–∫—Ä—ã—Ç—ã –∏–ª–∏ –Ω–µ –≤–∏–¥–Ω—ã',
                background: '–§–æ–Ω',
                backgroundPass: '–û–¥–Ω–æ—Ä–æ–¥–Ω—ã–π —Å–≤–µ—Ç–ª—ã–π —Ñ–æ–Ω',
                backgroundFail: '–§–æ–Ω –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º',
                compression: '–°–∂–∞—Ç–∏–µ',
                compressionPass: '–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∂–∞—Ç–∏—è –≤ –Ω–æ—Ä–º–µ',
                compressionFail: '–°–ª–∏—à–∫–æ–º —Å–∏–ª—å–Ω–æ–µ —Å–∂–∞—Ç–∏–µ',
                // Metadata labels
                dimensions: '–†–∞–∑–º–µ—Ä—ã',
                filesize: '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞',
                format: '–§–æ—Ä–º–∞—Ç',
                dateTaken: '–î–∞—Ç–∞ —Å—ä–µ–º–∫–∏',
                compressionRatio: '–°–∂–∞—Ç–∏–µ'
            },
            en: {
                appTitle: 'Green Card Photo Validator',
                appDescription: 'Professional photo validation tool for US Green Card lottery',
                uploadTitle: 'Upload Photo',
                uploadDesc: 'Drag and drop an image or click to select a file',
                uploadBtn: 'Select Photo',
                loadingModels: 'Loading face detection models...',
                processingImage: 'Processing image...',
                detectingFace: 'Detecting face...',
                analyzingPhoto: 'Analyzing photo...',
                detectionTitle: 'Face Detection',
                validationTitle: 'Validation Results',
                cropTitle: 'Processed Photo 600√ó600',
                downloadText: '‚¨á Download Photo',
                resetText: '‚Üª Upload Another Photo',
                successMessage: '‚úì All checks passed! Photo is ready to use.',
                // Validation labels
                faceDetected: 'Face Detection',
                faceDetectedPass: 'Face detected',
                faceDetectedFail: 'No face detected or multiple faces detected',
                fileFormat: 'File Format',
                fileFormatPass: 'JPEG format',
                fileFormatFail: 'JPEG format required',
                fileSize: 'File Size',
                fileSizePass: 'Size within limits',
                fileSizeFail: 'Size exceeds 240 KB',
                headHeight: 'Head Height',
                headHeightPass: 'Meets requirements (50-69%)',
                headHeightFail: 'Does not meet requirements (must be 50-69%)',
                eyePosition: 'Eye Position',
                eyePositionPass: 'Meets requirements (56-69%)',
                eyePositionFail: 'Does not meet requirements (must be 56-69%)',
                headTilt: 'Head Tilt',
                headTiltPass: 'Head is straight',
                headTiltFail: 'Head tilted more than 10¬∞',
                eyesOpen: 'Eyes Open',
                eyesOpenPass: 'Eyes are open',
                eyesOpenFail: 'Eyes closed or not visible',
                background: 'Background',
                backgroundPass: 'Uniform light background',
                backgroundFail: 'Background does not meet requirements',
                compression: 'Compression',
                compressionPass: 'Compression ratio within limits',
                compressionFail: 'Compression ratio too high',
                // Metadata labels
                dimensions: 'Dimensions',
                filesize: 'File Size',
                format: 'Format',
                dateTaken: 'Date Taken',
                compressionRatio: 'Compression'
            }
        };

        let currentLang = 'ru';
        let modelsLoaded = false;
        let currentImage = null;
        let detectionResult = null;

        // Update UI text based on language
        function updateLanguage() {
            const t = translations[currentLang];
            document.getElementById('appTitle').textContent = t.appTitle;
            document.getElementById('appDescription').textContent = t.appDescription;
            document.getElementById('uploadTitle').textContent = t.uploadTitle;
            document.getElementById('uploadDesc').textContent = t.uploadDesc;
            document.getElementById('uploadBtn').textContent = t.uploadBtn;
            document.getElementById('detectionTitle').textContent = t.detectionTitle;
            document.getElementById('validationTitle').textContent = t.validationTitle;
            document.getElementById('cropTitle').textContent = t.cropTitle;
            document.getElementById('downloadText').textContent = t.downloadText;
            document.getElementById('resetText').textContent = t.resetText;
            document.getElementById('successMessage').textContent = t.successMessage;
        }

        // Language selector
        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLang = btn.dataset.lang;
                updateLanguage();
                if (detectionResult) {
                    displayValidationResults(detectionResult);
                }
            });
        });

        // Load face-api & mediapipe models
        let mpInstance = null;
        let mpModel = null;

        async function loadMediaPipe() {
            if (mpInstance) return mpInstance;
            try {
                // –ü–æ–ø—ã—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å MediaPipe –µ—Å–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–∞
                if (window.poseDetection && window.poseDetection.createDetector) {
                    mpInstance = await window.poseDetection.createDetector(
                        window.poseDetection.SupportedModels.BlazePose,
                        {
                            runtime: 'tfjs',
                            enableSmoothing: true,
                            modelType: 'full'
                        }
                    );
                    console.log('‚úÖ MediaPipe BlazePose loaded');
                    return mpInstance;
                } else {
                    console.warn('‚ö†Ô∏è MediaPipe not available, using face-api only');
                    return null;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è MediaPipe warning:', error.message);
                return null;
            }
        }

        async function loadModels() {
            try {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
                ]);
                modelsLoaded = true;
                console.log('Models loaded successfully');
            } catch (error) {
                console.error('Error loading models:', error);
                alert('Error loading face detection models. Please refresh the page.');
            }
        }

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const processingSection = document.getElementById('processingSection');

        fileInput.addEventListener('change', handleFileSelect);

        // Drag and drop
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelect({ target: fileInput });
            }
        });

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show processing section
            uploadSection.style.display = 'none';
            processingSection.classList.add('active');
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('resultsGrid').classList.add('hidden');
            document.getElementById('cropPreview').classList.remove('active');

            const t = translations[currentLang];
            document.getElementById('loadingText').textContent = t.loadingModels;

            // Load models if not loaded
            if (!modelsLoaded) {
                await loadModels();
            }

            document.getElementById('loadingText').textContent = t.processingImage;

            // Process image
            await processImage(file);
        }

        async function processImage(file) {
            const t = translations[currentLang];
            
            try {
                // Read file as image
                const img = await loadImage(file);
                currentImage = img;

                // Get file metadata
                const metadata = await getImageMetadata(file, img);

                document.getElementById('loadingText').textContent = t.detectingFace;

                // 1. Run MediaPipe BlazePose/BlazeFace for full head, then face-api.js for facial details
                // Prepare offscreen canvas
                const offCanvas = document.createElement('canvas');
                offCanvas.width = img.width;
                offCanvas.height = img.height;
                const offCtx = offCanvas.getContext('2d');
                offCtx.drawImage(img, 0, 0, img.width, img.height);

                // Mediapipe (head/body) load and inference
                document.getElementById('loadingText').textContent = t.detectingFace;
                const mp = await loadMediaPipe();
                let mpHeadTopY = null;

                // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ MediaPipe (—Å fallback –µ—Å–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞)
                if (mp) {
                    try {
                        const mpPersons = await mp.estimatePoses(offCanvas, false);
                        if (mpPersons && mpPersons.length > 0) {
                            const poses = mpPersons[0].keypoints || [];
                            // –ù–∞–π–¥—ë–º –≤–µ—Ä—Ö–Ω—é—é —Ç–æ—á–∫—É (–º–∞–∫—É—à–∫—É) —á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫ —Å–∞–º–æ–π –≤–µ—Ä—Ö–Ω–µ–π —Ç–æ—á–∫–∏
                            const allYs = poses.map(p => p.y).filter(y => y > 0);
                            if (allYs.length > 0) {
                                mpHeadTopY = Math.min(...allYs);
                                console.log('‚úÖ MediaPipe head top found:', mpHeadTopY);
                            }
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è MediaPipe detection skipped:', e.message);
                        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å face-api (fallback)
                    }
                }

                // 2. Run face-api after
                const detection = await faceapi
                    .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks();
                document.getElementById('loadingText').textContent = t.analyzingPhoto;

                // Validate
                const validation = validateImage(img, detection, file, metadata, mpHeadTopY);

                detectionResult = { img, detection, validation, metadata, file, mpHeadTopY };
                displayResults(img, detection, validation, metadata, mpHeadTopY);

                document.getElementById('loadingIndicator').classList.add('hidden');
                document.getElementById('resultsGrid').classList.remove('hidden');
                if (validation.allPassed) {
                    await generateCroppedImage(img, detection, mpHeadTopY);
                }
            } catch (error) {
                console.error('Error processing image:', error);
                alert('Error processing image: ' + error.message);
            }
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        async function getImageMetadata(file, img) {
            const metadata = {
                width: img.width,
                height: img.height,
                fileSize: file.size,
                fileName: file.name,
                fileType: file.type,
                dateTaken: null
            };

            // Try to get EXIF data
            try {
                if (typeof exifr !== 'undefined') {
                    const exif = await exifr.parse(file);
                    if (exif && exif.DateTimeOriginal) {
                        metadata.dateTaken = exif.DateTimeOriginal;
                    }
                }
            } catch (error) {
                console.log('Could not read EXIF data:', error);
            }

            return metadata;
        }

        function validateImage(img, detection, file, metadata, mpHeadTopY) {
            const validation = {
                faceDetected: false,
                fileFormat: false,
                fileSize: false,
                headHeight: false,
                eyePosition: false,
                headTilt: false,
                eyesOpen: false,
                background: false,
                compression: false,
                allPassed: false,
                details: {}
            };

            // Face detection
            validation.faceDetected = detection !== undefined;
            
            // File format (JPEG)
            validation.fileFormat = file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpg') || file.name.toLowerCase().endsWith('.jpeg');
            
            // File size (‚â§ 240 KB)
            validation.fileSize = file.size <= 240 * 1024;
            validation.details.fileSize = Math.round(file.size / 1024);

            // For all key metrics, prefer MediaPipe for full head bounds if present
            let topOfHead = undefined, chin = undefined, eyeLevel = undefined;
            if (false) {
                topOfHead = mpHeadTopY;
                // chin from Mediapipe or face-api (use whichever is lower)
                let mpChinPoint = null;
                if (false) {
                    const chinPts = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('chin'));
                    if (chinPts.length > 0) {
                        mpChinPoint = Math.max(...chinPts.map(pt => pt.y));
                    }
                }
                if (detection) {
                    const jawline = detection.landmarks.getJawOutline();
                    const faChin = Math.max(...jawline.map(p => p.y));
                    chin = mpChinPoint != null ? Math.max(mpChinPoint, faChin) : faChin;
                } else {
                    chin = mpChinPoint;
                }
                // Eyes between Mediapipe and face-api
                if (detection) {
                    const leftEye = detection.landmarks.getLeftEye();
                    const rightEye = detection.landmarks.getRightEye();
                    eyeLevel = (leftEye[0].y + rightEye[0].y) / 2;
                } else if (false) {
                    const mpEyes = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('eye'));
                    if (mpEyes.length >= 2) {
                        eyeLevel = (mpEyes[0].y + mpEyes[1].y) / 2;
                    }
                }
            } else if (detection) {
                const landmarks = detection.landmarks;
                const positions = landmarks.positions;
                // classic fallback - not recommended
                topOfHead = Math.min(...positions.map(p => p.y));
                const jawline = landmarks.getJawOutline();
                chin = Math.max(...jawline.map(p => p.y));
                const leftEye = landmarks.getLeftEye();
                const rightEye = landmarks.getRightEye();
                eyeLevel = (leftEye[0].y + rightEye[0].y) / 2;
            }

            if (detection) {

                // Calculate head dimensions
                const jawline = landmarks.getJawOutline();
                const noseBridge = landmarks.getNose();
                const leftEye = landmarks.getLeftEye();
                const rightEye = landmarks.getRightEye();
                
                // Get key points
                const topOfHead = Math.min(...positions.map(p => p.y));
                const chin = Math.max(...jawline.map(p => p.y));
                const eyeLevel = (leftEye[0].y + rightEye[0].y) / 2;
                
                // Calculate percentages
                if (topOfHead != null && chin != null) {
                    const headHeight = chin - topOfHead;
                    const headHeightPercent = (headHeight / img.height) * 100;
                    validation.details.headHeightPercent = headHeightPercent.toFixed(1);
                    validation.headHeight = headHeightPercent >= 50 && headHeightPercent <= 69;
                }
                
                if (eyeLevel != null) {
                    // Green Card spec: eyes are 56-69% from bottom (so, (img.height - eyeLevel)/img.height)
                    const eyePositionPercent = ((img.height - eyeLevel) / img.height) * 100;
                    validation.details.eyePositionPercent = eyePositionPercent.toFixed(1);
                    validation.eyePosition = eyePositionPercent >= 56 && eyePositionPercent <= 69;
                }
                
                // Head tilt calculation
                const leftEyeCenter = { x: leftEye[0].x, y: leftEye[0].y };
                const rightEyeCenter = { x: rightEye[0].x, y: rightEye[0].y };
                const eyeAngle = Math.atan2(rightEyeCenter.y - leftEyeCenter.y, rightEyeCenter.x - leftEyeCenter.x);
                const tiltDegrees = Math.abs(eyeAngle * (180 / Math.PI));
                
                validation.details.tiltDegrees = tiltDegrees.toFixed(1);
                validation.headTilt = tiltDegrees < 10;
                
                // Eyes open check (basic heuristic based on eye landmarks)
                const leftEyeHeight = Math.abs(leftEye[1].y - leftEye[5].y);
                const rightEyeHeight = Math.abs(rightEye[1].y - rightEye[5].y);
                const avgEyeHeight = (leftEyeHeight + rightEyeHeight) / 2;
                validation.eyesOpen = avgEyeHeight > 2; // Threshold for open eyes
                
                // Background check (simplified - checks corners for uniform light color)
                validation.background = checkBackground(img);
                
                // Compression ratio estimation
                const uncompressedSize = img.width * img.height * 3; // 24-bit color
                const compressionRatio = uncompressedSize / file.size;
                validation.details.compressionRatio = compressionRatio.toFixed(1);
                validation.compression = compressionRatio <= 20;
            }

            // Check if all validations passed
            validation.allPassed = validation.faceDetected && 
                                   validation.fileFormat && 
                                   validation.fileSize && 
                                   validation.headHeight && 
                                   validation.eyePosition && 
                                   validation.headTilt && 
                                   validation.eyesOpen && 
                                   validation.background && 
                                   validation.compression;

            return validation;
        }

        function checkBackground(img) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // Sample corners
            const sampleSize = 20;
            const corners = [
                ctx.getImageData(0, 0, sampleSize, sampleSize),
                ctx.getImageData(img.width - sampleSize, 0, sampleSize, sampleSize),
                ctx.getImageData(0, img.height - sampleSize, sampleSize, sampleSize),
                ctx.getImageData(img.width - sampleSize, img.height - sampleSize, sampleSize, sampleSize)
            ];
            
            // Calculate average brightness and uniformity
            let totalBrightness = 0;
            let count = 0;
            
            corners.forEach(imageData => {
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                    totalBrightness += brightness;
                    count++;
                }
            });
            
            const avgBrightness = totalBrightness / count;
            
            // Check if background is light (> 200 out of 255) and relatively uniform
            return avgBrightness > 200;
        }

        function displayResults(img, detection, validation, metadata, mpHeadTopY) {
            // Draw all overlays
            drawDetectionCanvas(img, detection, mpHeadTopY);
            displayMetadata(metadata, validation.details);
            displayValidationResults(validation);
        }

        function drawDetectionCanvas(img, detection, mpHeadTopY) {
            // All drawing in SAME canvas for proper overlays
            const canvas = document.getElementById('detectionCanvas');
            const displayWidth = Math.min(600, img.width);
            const scale = displayWidth / img.width;
            canvas.width = displayWidth;
            canvas.height = img.height * scale;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Draw MediaPipe pose points as big blue/cyan dots if available
            if (mpKeypoints && mpKeypoints.length > 0) {
                ctx.fillStyle = '#1FB8CD';
                mpKeypoints.forEach(pt => {
                    if (typeof pt.x === 'number' && typeof pt.y === 'number') {
                        ctx.beginPath();
                        ctx.arc(pt.x * scale, pt.y * scale, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            }

            // Draw complete head contour polygon if possible
            if (headContour && headContour.length > 1) {
                ctx.save();
                ctx.strokeStyle = '#1FB8CD';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                headContour.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x * scale, pt.y * scale);
                    else ctx.lineTo(pt.x * scale, pt.y * scale);
                });
                ctx.closePath();
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }

            // Draw face-api classic 68 pts as magenta
            if (detection) {
                ctx.fillStyle = '#FFC185';
                const landmarks = detection.landmarks;
                landmarks.positions.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x * scale, p.y * scale, 1.8, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            // Draw reference lines (top/crown, eyes, chin)
            let topY, eyeY, chinY;
            // yellow: top, green: eyes, red: chin
            if (mpHeadTopY != null) {
                topY = mpHeadTopY * scale;
            } else if (detection) {
                const lp = detection.landmarks.positions;
                topY = Math.min(...lp.map(p => p.y)) * scale;
            }
            if (detection) {
                const leftEye = detection.landmarks.getLeftEye().map(p => p.y * scale);
                const rightEye = detection.landmarks.getRightEye().map(p => p.y * scale);
                eyeY = (leftEye[0] + rightEye[0]) / 2;
            } else if (false) {
                const mpEyes = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('eye'));
                if (mpEyes.length >= 2) {
                    eyeY = (mpEyes[0].y + mpEyes[1].y) / 2 * scale;
                }
            }
            if (mpDetection && mpDetection.keypoints) {
                // Use whichever is lower (more towards the bottom), face-api chin or mediapipe chin
                let mediapipeChin = null;
                const chins = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('chin'));
                if (chins.length > 0) mediapipeChin = Math.max(...chins.map(p => p.y)) * scale;
                if (detection) {
                    const jaw = detection.landmarks.getJawOutline().map(p => p.y * scale);
                    chinY = Math.max(mediapipeChin || 0, ...jaw);
                } else if (mediapipeChin) {
                    chinY = mediapipeChin;
                }
            } else if (detection) {
                chinY = Math.max(...detection.landmarks.getJawOutline().map(p => p.y * scale));
            }
            // Draw lines
            ctx.save();
            ctx.setLineDash([6, 4]);
            if (topY) {
                ctx.strokeStyle = 'yellow';
                ctx.beginPath(); ctx.moveTo(0, topY); ctx.lineTo(canvas.width, topY); ctx.stroke();
                ctx.fillStyle = 'yellow'; ctx.font = '13px sans-serif';
                ctx.fillText('Top/Crown', 7, topY - 6);
            }
            if (eyeY) {
                ctx.strokeStyle = 'lime';
                ctx.beginPath(); ctx.moveTo(0, eyeY); ctx.lineTo(canvas.width, eyeY); ctx.stroke();
                ctx.fillStyle = 'lime'; ctx.font = '13px sans-serif';
                ctx.fillText('Eyes', 7, eyeY - 6);
            }
            if (chinY) {
                ctx.strokeStyle = 'red';
                ctx.beginPath(); ctx.moveTo(0, chinY); ctx.lineTo(canvas.width, chinY); ctx.stroke();
                ctx.fillStyle = 'red'; ctx.font = '13px sans-serif';
                ctx.fillText('Chin', 7, chinY + 15);
            }
            ctx.setLineDash([]);
            ctx.restore();

            // Show which points influence which line (by bigger dot)
            // Top: highlight crown point
            if (mpHeadTopY != null && mpKeypoints && mpKeypoints.length > 0) {
                const tops = mpKeypoints.filter(pt => pt.y === mpHeadTopY);
                ctx.fillStyle = 'yellow';
                tops.forEach(pt => {
                    ctx.beginPath(); ctx.arc(pt.x * scale, pt.y * scale, 5, 0, 2 * Math.PI); ctx.fill();
                });
            }
        }

        function displayMetadata(metadata, details) {
            const t = translations[currentLang];
            const grid = document.getElementById('metadataGrid');
            grid.innerHTML = `
                <div class="metadata-item">
                    <span class="metadata-label">${t.dimensions}</span>
                    <span class="metadata-value">${metadata.width}√ó${metadata.height}px</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">${t.filesize}</span>
                    <span class="metadata-value">${details.fileSize} KB</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">${t.format}</span>
                    <span class="metadata-value">${metadata.fileType}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">${t.compressionRatio}</span>
                    <span class="metadata-value">${details.compressionRatio}:1</span>
                </div>
            `;
            
            if (metadata.dateTaken) {
                grid.innerHTML += `
                    <div class="metadata-item">
                        <span class="metadata-label">${t.dateTaken}</span>
                        <span class="metadata-value">${new Date(metadata.dateTaken).toLocaleDateString()}</span>
                    </div>
                `;
            }
        }

        function displayValidationResults(validation) {
            const t = translations[currentLang];
            const list = document.getElementById('validationList');
            
            const checks = [
                {
                    key: 'faceDetected',
                    label: t.faceDetected,
                    pass: validation.faceDetected,
                    passText: t.faceDetectedPass,
                    failText: t.faceDetectedFail
                },
                {
                    key: 'fileFormat',
                    label: t.fileFormat,
                    pass: validation.fileFormat,
                    passText: t.fileFormatPass,
                    failText: t.fileFormatFail
                },
                {
                    key: 'fileSize',
                    label: t.fileSize,
                    pass: validation.fileSize,
                    passText: t.fileSizePass + ` (${validation.details.fileSize} KB)`,
                    failText: t.fileSizeFail + ` (${validation.details.fileSize} KB)`
                },
                {
                    key: 'headHeight',
                    label: t.headHeight,
                    pass: validation.headHeight,
                    passText: t.headHeightPass + ` (${validation.details.headHeightPercent}%)`,
                    failText: t.headHeightFail + ` (${validation.details.headHeightPercent}%)`
                },
                {
                    key: 'eyePosition',
                    label: t.eyePosition,
                    pass: validation.eyePosition,
                    passText: t.eyePositionPass + ` (${validation.details.eyePositionPercent}%)`,
                    failText: t.eyePositionFail + ` (${validation.details.eyePositionPercent}%)`
                },
                {
                    key: 'headTilt',
                    label: t.headTilt,
                    pass: validation.headTilt,
                    passText: t.headTiltPass + ` (${validation.details.tiltDegrees}¬∞)`,
                    failText: t.headTiltFail + ` (${validation.details.tiltDegrees}¬∞)`
                },
                {
                    key: 'eyesOpen',
                    label: t.eyesOpen,
                    pass: validation.eyesOpen,
                    passText: t.eyesOpenPass,
                    failText: t.eyesOpenFail
                },
                {
                    key: 'background',
                    label: t.background,
                    pass: validation.background,
                    passText: t.backgroundPass,
                    failText: t.backgroundFail
                },
                {
                    key: 'compression',
                    label: t.compression,
                    pass: validation.compression,
                    passText: t.compressionPass + ` (${validation.details.compressionRatio}:1)`,
                    failText: t.compressionFail + ` (${validation.details.compressionRatio}:1)`
                }
            ];
            
            list.innerHTML = checks.map(check => `
                <li class="validation-item ${check.pass ? 'pass' : 'fail'}">
                    <span class="validation-icon">${check.pass ? '‚úì' : '‚úó'}</span>
                    <div class="validation-text">
                        <span class="validation-label">${check.label}</span>
                        <span class="validation-detail">${check.pass ? check.passText : check.failText}</span>
                    </div>
                </li>
            `).join('');
        }

        async function generateCroppedImage(img, detection, mpHeadTopY) {
            // Crop by MediaPipe crown and chin if available, fallback to face-api
            let topOfHead = undefined, chin = undefined, centerX = undefined, centerY = undefined;
            if (false) {
                topOfHead = mpHeadTopY;
                // chin from mediapipe or face-api (use whichever is lower)
                let mpChin = null;
                if (false) {
                    const chins = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('chin'));
                    if (chins.length > 0) mpChin = Math.max(...chins.map(pt => pt.y));
                }
                if (detection) {
                    const jaw = detection.landmarks.getJawOutline();
                    const faChin = Math.max(...jaw.map(p => p.y));
                    chin = mpChin != null ? Math.max(mpChin, faChin) : faChin;
                } else {
                    chin = mpChin;
                }
                // Center X as midpoint between left & right ear (from mediapipe if present), else box
                const ears = mpDetection.keypoints.filter(kp => kp.name && kp.name.includes('ear'));
                if (ears.length >= 2) {
                    centerX = (ears[0].x + ears[1].x) / 2;
                } else if (detection) {
                    centerX = detection.box.x + detection.box.width / 2;
                } else {
                    centerX = img.width / 2;
                }
                centerY = (topOfHead + chin) / 2;
            } else if (detection) {
                const landmarks = detection.landmarks;
                topOfHead = Math.min(...landmarks.positions.map(p => p.y));
                const jawline = landmarks.getJawOutline();
                chin = Math.max(...jawline.map(p => p.y));
                centerX = detection.box.x + detection.box.width / 2;
                centerY = (topOfHead + chin) / 2;
            } else {
                // Cannot crop!
                return;
            }
            const headHeight = chin - topOfHead;
            // Crop size such that head is 60% of 600px (middle of allowed interval)
            const targetHeadPercent = 0.60;
            const cropPx = headHeight / targetHeadPercent;
            const sourceSize = Math.max(cropPx, 600); // Don't crop smaller than 600
            const srcX = Math.max(0, centerX - sourceSize / 2);
            const srcY = Math.max(0, centerY - sourceSize / 2);
            // Draw
            const canvas = document.getElementById('croppedCanvas');
            canvas.width = 600;
            canvas.height = 600;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 600, 600);
            ctx.drawImage(img, srcX, srcY, sourceSize, sourceSize, 0, 0, 600, 600);
            document.getElementById('cropPreview').classList.add('active');
        }

        // Download button
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const canvas = document.getElementById('croppedCanvas');
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'greencard_photo_600x600.jpg';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/jpeg', 0.95);
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            uploadSection.style.display = 'block';
            processingSection.classList.remove('active');
            document.getElementById('cropPreview').classList.remove('active');
            fileInput.value = '';
            currentImage = null;
            detectionResult = null;
        });

        // Initialize
        updateLanguage();
    </script>
</body>
</html>
